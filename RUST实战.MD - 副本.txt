第 一 部分　Rust语言的特色

第 1章　Rust语言介绍
1.1　哪些地方使用了Rust？
1.2　在工作中提倡使用Rust
1.3　Rust初体验
1.3.1　直通“Hello， world!”
1.3.2　第 一个Rust程序
1.4　下载本书源代码
1.5　使用Rust语言的感受如何
1.6　Rust语言是什么？
1.6.1　Rust的目标：安全性
1.6.2　Rust的目标：生产力
1.6.3　Rust的目标：控制
1.7　Rust的主要特点
1.7.1　性能
1.7.2　并发
1.7.3　内存使用效率
1.8　Rust的缺点
1.8.1　循环数据结构
1.8.2　编译速度
1.8.3　严格
1.8.4　语言的大小
1.8.5　炒作
1.9　TLS安全性问题的研究
1.9.1 “心脏出血”
1.9.2　跳转到失败
1.10　Rust最适用于哪些领域？
1.10.1　命令行实用程序
1.10.2　数据处理
1.10.3　扩展应用程序
1.10.4　资源受限的环境
1.10.5　服务器端应用
1.10.6　桌面应用程序
1.10.7　桌面
1.10.8　移动端
1.10.9　Web
1.10.10　系统编程
1.11　Rust的隐式特性：它的社区
1.12　Rust术语表
本章小结
第 2章　Rust语言基础
2.1　创建一个可运行的程序
2.1.1　编译单文件的Rust程序
2.1.2　使用cargo编译Rust项目
2.2　初探Rust语法
2.3　数字类型
2.3.1　整数和浮点数
2.3.2　整数的二进制、八进制及十六进制表示法
2.3.3　数字的比较运算
2.3.4　有理数、复数和其他数字类型
2.4　流程控制
2.4.1　for循环：迭代的中心支柱
2.4.2　continue：跳过本次迭代余下的部分
2.4.3　while：循环，直到循环条件改变了循环的状态
2.4.4　loop：Rust循环结构的基本组件
2.4.5　break：立即退出循环
2.4.6　if、if else和else：条件测试
2.4.7　match：类型感知的模式匹配
2.5　定义函数
2.6　使用引用
2.7　项目：绘制芒德布罗集
2.8　高级函数定义
2.8.1　显式生命周期注解
2.8.2　泛型函数
2.9　创建grep-lite
2.10　使用数组、切片和动态数组来创建数据列表
2.10.1　数组
2.10.2　切片
2.10.3　动态数组
2.11　包含第三方代码
2.11.1　增加对正则表达式的支持
2.11.2　生成包的本地化文档
2.11.3　使用rustup管理Rust工具链
2.12　命令行参数的支持
2.13　从文件中读取
2.14　从标准输入中读取
本章小结
第3章　复合数据类型
3.1　使用普通函数对API进行实验
3.2　使用结构体为文件建模
3.3　使用impl为结构体添加方法
3.4　返回错误信息
3.4.1　修改一个著名的全局变量
3.4.2　使用Result作为返回类型
3.5　定义并使用枚举体
3.6　使用trait来定义共有的行为
3.6.1　创建名为Read的trait
3.6.2　为类型实现std：：fmt：：Display
3.7　将类型暴露给外部使用
3.8　创建内联文档
3.8.1　使用rustdoc给单个源文件生成文档
3.8.2　使用cargo为一个包及其依赖的包生成文档
本章小结
第4章　生命周期、所有权和借用
4.1　实现一个模拟的立方体卫星地面站
4.1.1　遇到第 一个生命周期问题
4.1.2　基本类型的特殊行为
4.2　本章图例的说明
4.3　所有者是什么？它有什么职责？
4.4　所有权是如何移动的？
4.5　解决所有权的问题
4.5.1　在不需要完整所有权的地方，使用引用
4.5.2　使用更少的长存活期的值
4.5.3　在需要完整所有权的地方，复制长存活期的值
4.5.4　把数据包装到特殊的类型中
本章小结

第二部分　揭开系统编程的神秘面纱

第5章　深入理解数据
5.1　位模式和类型
5.2　整数的生存范围
5.3　小数的表示形式
5.4　浮点数
5.4.1　观察f32的内部
5.4.2　分离出符号位
5.4.3　分离出指数
5.4.4　分离出尾数
5.4.5　剖析一个浮点数
5.5　定点数格式
5.6　从随机字节中生成随机概率
5.7　实现一个CPU模拟器以建立函数也是数据的观念
5.7.1　CPU原型1：加法器
5.7.2　CPU原型1完整的清单
5.7.3　CPU原型2：累加器
5.7.4　CPU原型3：调用函数
5.7.5　CPU 4：添加额外功能
本章小结
第6章　内存
6.1　指针
6.2　探索Rust的引用和指针类型
6.2.1　Rust中的原始指针
6.2.2　Rust指针的生态系统
6.2.3　智能指针构建块
6.3　为程序提供存储数据的内存
6.3.1　栈
6.3.2　堆
6.3.3　什么是动态内存分配？
6.3.4　分析动态内存分配的影响
6.4　虚拟内存
6.4.1　背景
6.4.2　第 一步：让一个进程来扫描它自己的内存
6.4.3　把虚拟地址翻译为物理地址
6.4.4　第二步：通过操作系统来扫描地址空间
6.4.5　第三步：读取和写入进程内存中的字节数据
本章小结
第7章　文件与存储
7.1　文件格式是什么？
7.2　创建你自己的用于存储数据的文件格式
7.3　实现一个hexdump的克隆
7.4　Rust中的文件操作
7.4.1　使用Rust打开一个文件并控制文件的模式
7.4.2　使用std：：fs：：Path以一种类型安全的方式与文件系统进行交互
7.5　使用基于日志结构、仅追加的存储架构，来实现一个键值存储
7.5.1　键值模型
7.5.2　讲解actionkv v1：一个带有命令行接口的内存中的键值存储
7.6　Actionkv v1：前端代码
7.7　理解ACTIONKV的核心：LIBACTIONKV包
7.7.1　初始化ActionKV结构体
7.7.2　处理单条记录
7.7.3　以确定的字节顺序将多字节二进制数据写入磁盘
7.7.4　使用校验和来验证I/O错误
7.7.5　向已存在的数据库中插入一个新的键值对
7.7.6　actionkv的完整清单
7.7.7　使用HashMap和BTreeMap来处理键和值
7.7.8　创建一个HashMap并用值来填充它
7.7.9　从HashMap和BTreeMap中来检索值
7.7.10　在HashMap和BTreeMap之间如何选择
7.7.11　给actionkv v2.0添加数据库索引
本章小结
第8章　网络
8.1　全部的网络体系都在7个分层中
8.2　使用reqwest来生成一个HTTP GET请求
8.3　trait对象
8.3.1　trait对象能做什么？
8.3.2　trait对象是什么？
8.3.3　创建一个微型的角色扮演游戏：rpg项目
8.4　TCP
8.4.1　端口号是什么？
8.4.2　把主机名转换为IP地址
8.5　以符合工效学的方式处理来自多个包的错误
8.5.1　问题：无法返回多种错误类型
8.5.2　通过定义错误类型来包装下游的错误
8.5.3　使用unwrap()和expect()来“作弊”
8.6　MAC地址
8.7　使用Rust的枚举体来实现状态机
8.8　原始TCP
8.9　创建一个虚拟网络设备
8.10　原始HTTP
本章小结
第9章　时间与时间保持
9.1　背景
9.2　时间源
9.3　一些相关的术语定义
9.4　时间的编码
9.5　clock v0.1.0：教会一个应用程序如何报时
9.6　clock v0.1.1：格式化时间戳以符合ISO1和电子邮件的标准
9.6.1　重构clock v0.1.0的代码以支持更广泛的体系结构
9.6.2　时间的格式化
9.6.3　提供一个完整的命令行接口
9.6.4　clock v0.1.1：完整的项目代码
9.7　clock v0.1.2：设置时间
9.7.1　相同的行为模式
9.7.2　给使用libc的操作系统来设置时间
9.7.3　在Windows上设置时间
9.7.4　clock v0.1.2：完整的清单
9.8　改善错误处理
9.9　clock v0.1.3：使用NTP来解决时钟之间的差异
9.9.1　发送NTP请求并解析响应
9.9.2　依据服务器的响应来调整本地时间
9.9.3　在使用了不同的精度和纪元的时间表示法之间进行转换
9.9.4　clock v0.1.3：完整的清单
本章小结
第 10章　进程、线程和容器
10.1　匿名函数
10.2　产生线程
10.2.1　引入闭包
10.2.2　产生一个新线程
10.2.3　产生几个线程的效果
10.2.4　产生很多个线程的效果
10.2.5　重新生成这些结果
10.2.6　共享的变量
10.3　闭包与函数的差异
10.4　从多线程解析器和代码生成器中程序化地生成头像
10.4.1　如何运行render-hex以及预期的输出
10.4.2　单线程版本render-hex的概要介绍
10.4.3　为每个逻辑上的任务产生一个线程
10.4.4　使用线程池和任务队列
10.5　并发与任务虚拟化
10.5.1　线程
10.5.2　上下文切换是什么？
10.5.3　进程
10.5.4　WebAssembly
10.5.5　容器
10.5.6　为什么要使用操作系统呢？
本章小结
第 11章　内核
11.1　初级操作系统（FledgeOS）
11.1.1　搭建开发环境，用于开发操作系统内核
11.1.2　验证开发环境
11.2　Fledgeos-0：先让一些东西能运行起来
11.2.1　第 一次引导启动
11.2.2　编译的步骤
11.2.3　源清单
11.2.4　处理panic
11.2.5　使用VGA兼容的文本模式写入屏幕
11.2.6　_start()：FledgeOS的main()函数
11.3　fledgeos-1：避免使用忙循环
11.3.1　通过直接与CPU交互来降低功耗
11.3.2　fledgeos-1的源代码
11.4　fledgeos-2：自定义异常处理
11.4.1　几乎可以正确地处理异常
11.4.2　fledgeos-2的源代码
11.5　fledgeos-3：文本的输出
11.5.1　把彩色的文本输出到屏幕
11.5.2　控制枚举体的内存表示形式
11.5.3　为何要使用枚举体？
11.5.4　创建出一个类型，能够用来输出到VGA的帧缓冲区
11.5.5　输出到屏幕
11.5.6　fledgeos-3的源代码
11.6　fledgeos-4：自定义恐慌处理
11.6.1　实现一个恐慌处理程序，能够向用户报告错误
11.6.2　使用core：：fmt：：Write来重新实现panic()
11.6.3　实现core：：fmt：：Write
11.6.4　fledgeos-4的源代码
本章小结
第 12章　信号、中断和异常
12.1　术语表
12.2　中断是如何影响应用程序的？
12.3　软件中断
12.4　硬件中断
12.5　信号处理
12.5.1　默认的行为
12.5.2　用来暂停和恢复一个程序的操作
12.5.3　列出操作系统支持的所有信号
12.6　使用自定义的行为来处理信号
12.6.1　在Rust中使用全局变量
12.6.2　使用全局变量来指示已经启动了关机
12.7　发送由应用程序定义的信号
12.8　如何忽略信号？
12.9　从深层嵌套的调用栈中关闭程序
12.9.1　sjlj项目的介绍
12.9.2　在程序中设置固有函数
12.9.3　把指针转换成其他类型
12.9.4　编译sjlj项目
12.9.5　sjlj项目的源代码
12.10　将这些技术应用于不支持信号的平台的说明
12.11　修订异常
本章小结
