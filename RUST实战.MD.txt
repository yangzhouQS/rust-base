第 一 部分　Rust语言的特色

第 1章　Rust语言介绍　3
1．1　哪些地方使用了Rust？　4
1．2　在工作中提倡使用Rust　5
1．3　Rust初体验　6
1．3．1　直通“Hello， world!”　6
1．3．2　第 一个Rust程序　8
1．4　下载本书源代码　10
1．5　使用Rust语言的感受如何　10
1．6　Rust语言是什么？　13
1．6．1　Rust的目标：安全性　14
1．6．2　Rust的目标：生产力　18
1．6．3　Rust的目标：控制　19
1．7　Rust的主要特点　20
1．7．1　性能　20
1．7．2　并发　21
1．7．3　内存使用效率　21
1．8　Rust的缺点　21
1．8．1　循环数据结构　21
1．8．2　编译速度　22
1．8．3　严格　22
1．8．4　语言的大小　22
1．8．5　炒作　22
1．9　TLS安全性问题的研究　22
1．9．1 “心脏出血”　23
1．9．2　跳转到失败　23
1．10　Rust最适用于哪些领域？　25
1．10．1　命令行实用程序　25
1．10．2　数据处理　25
1．10．3　扩展应用程序　25
1．10．4　资源受限的环境　26
1．10．5　服务器端应用　26
1．10．6　桌面应用程序　26
1．10．7　桌面　26
1．10．8　移动端　27
1．10．9　Web　27
1．10．10　系统编程　27
1．11　Rust的隐式特性：它的社区　27
1．12　Rust术语表　28
本章小结　28
第 2章　Rust语言基础　29
2．1　创建一个可运行的程序　30
2．1．1　编译单文件的Rust程序　30
2．1．2　使用cargo编译Rust项目　31
2．2　初探Rust语法　32
2．3　数字类型　34
2．3．1　整数和浮点数　34
2．3．2　整数的二进制、八进制及十六进制表示法　35
2．3．3　数字的比较运算　36
2．3．4　有理数、复数和其他数字类型　41
2．4　流程控制　43
2．4．1　for循环：迭代的中心支柱　43
2．4．2　continue：跳过本次迭代余下的部分　45
2．4．3　while：循环，直到循环条件改变了循环的状态　45
2．4．4　loop：Rust循环结构的基本组件　46
2．4．5　break：立即退出循环　46
2．4．6　if、if else和else：条件测试　47
2．4．7　match：类型感知的模式匹配　48
2．5　定义函数　50
2．6　使用引用　50
2．7　项目：绘制芒德布罗集　51
2．8　高级函数定义　54
2．8．1　显式生命周期注解　54
2．8．2　泛型函数　55
2．9　创建grep-lite　58
2．10　使用数组、切片和动态数组来创建数据列表　61
2．10．1　数组　61
2．10．2　切片　63
2．10．3　动态数组　63
2．11　包含第三方代码　65
2．11．1　增加对正则表达式的支持　66
2．11．2　生成包的本地化文档　67
2．11．3　使用rustup管理Rust工具链　68
2．12　命令行参数的支持　68
2．13　从文件中读取　70
2．14　从标准输入中读取　72
本章小结　73
第3章　复合数据类型　75
3．1　使用普通函数对API进行实验　76
3．2　使用结构体为文件建模　77
3．3　使用impl为结构体添加方法　81
3．4　返回错误信息　84
3．4．1　修改一个著名的全局变量　85
3．4．2　使用Result作为返回类型　88
3．5　定义并使用枚举体　91
3．6　使用trait来定义共有的行为　95
3．6．1　创建名为Read的trait　95
3．6．2　为类型实现std：：fmt：：Display　96
3．7　将类型暴露给外部使用　99
3．8　创建内联文档　100
3．8．1　使用rustdoc给单个源文件生成文档　101
3．8．2　使用cargo为一个包及其依赖的包生成文档　101
本章小结　103
第4章　生命周期、所有权和借用　104
4．1　实现一个模拟的立方体卫星地面站　105
4．1．1　遇到第 一个生命周期问题　106
4．1．2　基本类型的特殊行为　109
4．2　本章图例的说明　110
4．3　所有者是什么？它有什么职责？　111
4．4　所有权是如何移动的？　112
4．5　解决所有权的问题　114
4．5．1　在不需要完整所有权的地方，使用引用　116
4．5．2　使用更少的长存活期的值　119
4．5．3　在需要完整所有权的地方，复制长存活期的值　124
4．5．4　把数据包装到特殊的类型中　127
本章小结　129

第二部分　揭开系统编程的神秘面纱

第5章　深入理解数据　133
5．1　位模式和类型　133
5．2　整数的生存范围　135
5．3　小数的表示形式　139
5．4　浮点数　139
5．4．1　观察f32的内部　140
5．4．2　分离出符号位　141
5．4．3　分离出指数　142
5．4．4　分离出尾数　143
5．4．5　剖析一个浮点数　145
5．5　定点数格式　147
5．6　从随机字节中生成随机概率　151
5．7　实现一个CPU模拟器以建立函数也是数据的观念　153
5．7．1　CPU原型1：加法器　153
5．7．2　CPU原型1完整的清单　157
5．7．3　CPU原型2：累加器　159
5．7．4　CPU原型3：调用函数　162
5．7．5　CPU 4：添加额外功能　168
本章小结　168
第6章　内存　169
6．1　指针　169
6．2　探索Rust的引用和指针类型　171
6．2．1　Rust中的原始指针　176
6．2．2　Rust指针的生态系统　178
6．2．3　智能指针构建块　180
6．3　为程序提供存储数据的内存　181
6．3．1　栈　181
6．3．2　堆　183
6．3．3　什么是动态内存分配？　187
6．3．4　分析动态内存分配的影响　192
6．4　虚拟内存　194
6．4．1　背景　195
6．4．2　第 一步：让一个进程来扫描它自己的内存　196
6．4．3　把虚拟地址翻译为物理地址　198
6．4．4　第二步：通过操作系统来扫描地址空间　201
6．4．5　第三步：读取和写入进程内存中的字节数据　203
本章小结　203
第7章　文件与存储　204
7．1　文件格式是什么？　204
7．2　创建你自己的用于存储数据的文件格式　206
7．3　实现一个hexdump的克隆　208
7．4　Rust中的文件操作　211
7．4．1　使用Rust打开一个文件并控制文件的模式　211
7．4．2　使用std：：fs：：Path以一种类型安全的方式与文件系统进行交互　212
7．5　使用基于日志结构、仅追加的存储架构，来实现一个键值存储　213
7．5．1　键值模型　213
7．5．2　讲解actionkv v1：一个带有命令行接口的内存中的键值存储　214
7．6　Actionkv v1：前端代码　215
7．7　理解ACTIONKV的核心：LIBACTIONKV包　219
7．7．1　初始化ActionKV结构体　219
7．7．2　处理单条记录　221
7．7．3　以确定的字节顺序将多字节二进制数据写入磁盘　223
7．7．4　使用校验和来验证I/O错误　225
7．7．5　向已存在的数据库中插入一个新的键值对　227
7．7．6　actionkv的完整清单　228
7．7．7　使用HashMap和BTreeMap来处理键和值　232
7．7．8　创建一个HashMap并用值来填充它　234
7．7．9　从HashMap和BTreeMap中来检索值　235
7．7．10　在HashMap和BTreeMap之间如何选择　236
7．7．11　给actionkv v2．0添加数据库索引　237
本章小结　240
第8章　网络　242
8．1　全部的网络体系都在7个分层中　243
8．2　使用reqwest来生成一个HTTP GET请求　245
8．3　trait对象　247
8．3．1　trait对象能做什么？　247
8．3．2　trait对象是什么？　247
8．3．3　创建一个微型的角色扮演游戏：rpg项目　248
8．4　TCP　251
8．4．1　端口号是什么？　252
8．4．2　把主机名转换为IP地址　252
8．5　以符合工效学的方式处理来自多个包的错误　258
8．5．1　问题：无法返回多种错误类型　259
8．5．2　通过定义错误类型来包装下游的错误　262
8．5．3　使用unwrap()和expect()来“作弊”　267
8．6　MAC地址　268
8．7　使用Rust的枚举体来实现状态机　271
8．8　原始TCP　272
8．9　创建一个虚拟网络设备　272
8．10　原始HTTP　273
本章小结　282
第9章　时间与时间保持　283
9．1　背景　284
9．2　时间源　285
9．3　一些相关的术语定义　286
9．4　时间的编码　287
9．5　clock v0．1．0：教会一个应用程序如何报时　288
9．6　clock v0．1．1：格式化时间戳以符合ISO 8601和电子邮件的标准　289
9．6．1　重构clock v0．1．0的代码以支持更广泛的体系结构　290
9．6．2　时间的格式化　291
9．6．3　提供一个完整的命令行接口　291
9．6．4　clock v0．1．1：完整的项目代码　293
9．7　clock v0．1．2：设置时间　295
9．7．1　相同的行为模式　295
9．7．2　给使用libc的操作系统来设置时间　296
9．7．3　在Windows上设置时间　298
9．7．4　clock v0．1．2：完整的清单　300
9．8　改善错误处理　303
9．9　clock v0．1．3：使用NTP来解决时钟之间的差异　304
9．9．1　发送NTP请求并解析响应　304
9．9．2　依据服务器的响应来调整本地时间　306
9．9．3　在使用了不同的精度和纪元的时间表示法之间进行转换　308
9．9．4　clock v0．1．3：完整的清单　309
本章小结　316
第 10章　进程、线程和容器　318
10．1　匿名函数　319
10．2　产生线程　320
10．2．1　引入闭包　320
10．2．2　产生一个新线程　321
10．2．3　产生几个线程的效果　321
10．2．4　产生很多个线程的效果　322
10．2．5　重新生成这些结果　324
10．2．6　共享的变量　328
10．3　闭包与函数的差异　330
10．4　从多线程解析器和代码生成器中程序化地生成头像　331
10．4．1　如何运行render-hex以及预期的输出　331
10．4．2　单线程版本render-hex的概要介绍 333
10．4．3　为每个逻辑上的任务产生一个线程　341
10．4．4　使用线程池和任务队列　343
10．5　并发与任务虚拟化　350
10．5．1　线程　352
10．5．2　上下文切换是什么？　352
10．5．3　进程　353
10．5．4　WebAssembly　353
10．5．5　容器　353
10．5．6　为什么要使用操作系统呢？　354
本章小结　354
第 11章　内核　355
11．1　初级操作系统（FledgeOS）　355
11．1．1　搭建开发环境，用于开发操作系统内核　355
11．1．2　验证开发环境　357
11．2　Fledgeos-0：先让一些东西能运行起来　358
11．2．1　第 一次引导启动　358
11．2．2　编译的步骤　359
11．2．3　源清单　360
11．2．4　处理panic　364
11．2．5　使用VGA兼容的文本模式写入屏幕　365
11．2．6　_start()：FledgeOS的main()函数　366
11．3　fledgeos-1：避免使用忙循环　367
11．3．1　通过直接与CPU交互来降低功耗　367
11．3．2　fledgeos-1的源代码　368
11．4　fledgeos-2：自定义异常处理　369
11．4．1　几乎可以正确地处理异常　369
11．4．2　fledgeos-2的源代码　369
11．5　fledgeos-3：文本的输出　370
11．5．1　把彩色的文本输出到屏幕　371
11．5．2　控制枚举体的内存表示形式　371
11．5．3　为何要使用枚举体？　372
11．5．4　创建出一个类型，能够用来输出到VGA的帧缓冲区　372
11．5．5　输出到屏幕　373
11．5．6　fledgeos-3的源代码　373
11．6　fledgeos-4：自定义恐慌处理　375
11．6．1　实现一个恐慌处理程序，能够向用户报告错误　375
11．6．2　使用core：：fmt：：Write来重新实现panic()　376
11．6．3　实现core：：fmt：：Write　376
11．6．4　fledgeos-4的源代码　377
本章小结　379
第 12章　信号、中断和异常　380
12．1　术语表　380
12．2　中断是如何影响应用程序的？　383
12．3　软件中断　384
12．4　硬件中断　385
12．5　信号处理　386
12．5．1　默认的行为　386
12．5．2　用来暂停和恢复一个程序的操作　386
12．5．3　列出操作系统支持的所有信号　389
12．6　使用自定义的行为来处理信号　389
12．6．1　在Rust中使用全局变量　390
12．6．2　使用全局变量来指示已经启动了关机　392
12．7　发送由应用程序定义的信号　394
12．8　如何忽略信号？　396
12．9　从深层嵌套的调用栈中关闭程序　397
12．9．1　sjlj项目的介绍　399
12．9．2　在程序中设置固有函数　399
12．9．3　把指针转换成其他类型　401
12．9．4　编译sjlj项目　402
12．9．5　sjlj项目的源代码　403
12．10　将这些技术应用于不支持信号的平台的说明　406
12．11　修订异常　406
本章小结　406
